import{_ as t,a as o}from"./arthas-output-svg.30f64f53.js";import{_ as r,o as l,c as d,a,b as i,e,d as n,r as c}from"./app.5e87b7e3.js";const p={},h=a("h1",{id:"profiler",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#profiler","aria-hidden":"true"},"#"),e(" profiler")],-1),u={href:"https://arthas.aliyun.com/doc/arthas-tutorials.html?language=en&id=command-profiler",target:"_blank",rel:"noopener noreferrer"},m=a("code",null,"profiler",-1),f=e(" online tutorial"),v={class:"custom-container tip"},b=a("p",{class:"custom-container-title"},"TIP",-1),g=e("Generate a flame graph using "),_={href:"https://github.com/jvm-profiling-tools/async-profiler",target:"_blank",rel:"noopener noreferrer"},x=e("async-profiler"),y=a("p",null,[e("The "),a("code",null,"profiler"),e(" command supports generating flame graph for application hotspots.")],-1),k=a("p",null,[e("The basic usage of the "),a("code",null,"profiler"),e(" command is "),a("code",null,"profiler action [actionArg]")],-1),w=e("The arguments of "),j=a("code",null,"profiler",-1),T=e(" command basically keeps consistent with upstream project "),S={href:"https://github.com/async-profiler/async-profiler",target:"_blank",rel:"noopener noreferrer"},F=e("async-profiler"),C=e(", you can refer to its README, Github Discussions and other documentations for further information of usage."),B=n(`<h2 id="supported-options" tabindex="-1"><a class="header-anchor" href="#supported-options" aria-hidden="true">#</a> Supported Options</h2><table><thead><tr><th style="text-align:right;">Name</th><th style="text-align:left;">Specification</th></tr></thead><tbody><tr><td style="text-align:right;"><em>action</em></td><td style="text-align:left;">Action to execute</td></tr><tr><td style="text-align:right;"><em>actionArg</em></td><td style="text-align:left;">Attribute name pattern</td></tr><tr><td style="text-align:right;">[i:]</td><td style="text-align:left;">sampling interval in ns (default: 10&#39;000&#39;000, i.e. 10 ms)</td></tr><tr><td style="text-align:right;">[f:]</td><td style="text-align:left;">dump output to specified directory</td></tr><tr><td style="text-align:right;">[d:]</td><td style="text-align:left;">run profiling for specified seconds</td></tr><tr><td style="text-align:right;">[e:]</td><td style="text-align:left;">which event to trace (cpu, alloc, lock, cache-misses etc.), default value is cpu</td></tr></tbody></table><h2 id="start-profiler" tabindex="-1"><a class="header-anchor" href="#start-profiler" aria-hidden="true">#</a> Start profiler</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler start
Started [cpu] profiling
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>By default, the sample event is <code>cpu</code>. Other valid profiling modes can be specified with the <code>--event</code> parameter, see relevant contents below.</p></div><h2 id="get-the-number-of-samples-collected" tabindex="-1"><a class="header-anchor" href="#get-the-number-of-samples-collected" aria-hidden="true">#</a> Get the number of samples collected</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler getSamples
23
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="view-profiling-status" tabindex="-1"><a class="header-anchor" href="#view-profiling-status" aria-hidden="true">#</a> View profiling status</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler status
<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span> profiling is running <span class="token keyword">for</span> <span class="token number">4</span> seconds
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Can view which <code>event</code> and sampling time.</p><h2 id="view-profiler-memory-usage" tabindex="-1"><a class="header-anchor" href="#view-profiler-memory-usage" aria-hidden="true">#</a> View profiler memory usage</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler meminfo
Call trace storage:   10244 KB
      Dictionaries:      72 KB
        Code cache:   12890 KB
------------------------------
             Total:   23206 KB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="stop-profiler" tabindex="-1"><a class="header-anchor" href="#stop-profiler" aria-hidden="true">#</a> Stop profiler</h2><h3 id="generating-flame-graph-results" tabindex="-1"><a class="header-anchor" href="#generating-flame-graph-results" aria-hidden="true">#</a> Generating flame graph results</h3>`,14),J=e("By default, the result file is "),G=a("code",null,"html",-1),R=e(" file in "),I={href:"https://github.com/BrendanGregg/FlameGraph",target:"_blank",rel:"noopener noreferrer"},M=e("Flame Graph"),N=e(" format. You can also specify other format with the "),V=a("code",null,"-o",-1),A=e(" or "),E=a("code",null,"--format",-1),P=e(" parameter, including flat, traces, collapsed, flamegraph, tree, jfr:"),$=n(`<div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler stop <span class="token parameter variable">--format</span> flamegraph
profiler output file: /tmp/test/arthas-output/20211207-111550.html
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When extension of filename in <code>--file</code> parameter is <code>html</code> or <code>jfr</code>, the output format can be infered. For example, <code>--file /tmp/result.html</code> will generate flamegraph automatically.</p><h2 id="view-profiler-results-under-arthas-output-via-browser" tabindex="-1"><a class="header-anchor" href="#view-profiler-results-under-arthas-output-via-browser" aria-hidden="true">#</a> View profiler results under arthas-output via browser</h2>`,3),D=e("By default, arthas uses port 3658, which can be opened: "),L={href:"http://localhost:3658/arthas-output/",target:"_blank",rel:"noopener noreferrer"},O=e("http://localhost:3658/arthas-output/"),U=e(" View the "),Y=a("code",null,"arthas-output",-1),q=e(" directory below Profiler results:"),z=n('<p><img src="'+t+'" alt=""></p><p>Click to view specific results:</p><p><img src="'+o+`" alt=""></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>If using the chrome browser, may need to be refreshed multiple times.</p></div><h2 id="profiler-supported-events" tabindex="-1"><a class="header-anchor" href="#profiler-supported-events" aria-hidden="true">#</a> Profiler supported events</h2><p>Under different platforms and different OSs, the supported events are different. For example, under macos:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Under linux</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
Java method calls:
  ClassName.methodName
Perf events:
  page-faults
  context-switches
  cycles
  instructions
  cache-references
  cache-misses
  branch-instructions
  branch-misses
  bus-cycles
  L1-dcache-load-misses
  LLC-load-misses
  dTLB-load-misses
  rNNN
  pmu/event-descriptor/
  mem:breakpoint
  trace:tracepoint
  kprobe:func
  uprobe:path
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),K=e("If you encounter the permissions/configuration issues of the OS itself and then missing some events, you can refer to the "),H={href:"https://github.com/jvm-profiling-tools/async-profiler",target:"_blank",rel:"noopener noreferrer"},W=e("async-profiler"),X=e(" documentation."),Q=n(`<p>You can use <code>check</code> action to check if a profiling event is available, this action receives the same format options with <code>start</code>.</p><p>You can use the <code>--event</code> parameter to specify the event to sample, for example, <code>alloc</code> event means heap memory allocation profiling:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler start <span class="token parameter variable">--event</span> alloc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="resume-sampling" tabindex="-1"><a class="header-anchor" href="#resume-sampling" aria-hidden="true">#</a> Resume sampling</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler resume
Started <span class="token punctuation">[</span>cpu<span class="token punctuation">]</span> profiling
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The difference between <code>start</code> and <code>resume</code> is: <code>start</code> will clean existing result of last profiling before starting, <code>resume</code> will retain the existing result and add result of this time to it.</p><p>You can verify the number of samples by executing <code>profiler getSamples</code>.</p><h2 id="dump-action" tabindex="-1"><a class="header-anchor" href="#dump-action" aria-hidden="true">#</a> Dump action</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler dump
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>dump</code> action saves profiling result to default file or specified file, but profiling will continue. That means if you start profiling and dump after 5 seconds, then dump after 2 seconds again, you will get 2 result files, the first one contains profiling result of 0~5 seconds and the second one contains that of 0~7 seconds.</p><h2 id="use-execute-action-to-execute-complex-commands" tabindex="-1"><a class="header-anchor" href="#use-execute-action-to-execute-complex-commands" aria-hidden="true">#</a> Use <code>execute</code> action to execute complex commands</h2><p>For example, start sampling:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler execute <span class="token string">&#39;start,framebuf=5000000&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Stop sampling and save to the specified file:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler execute <span class="token string">&#39;stop,file=/tmp/result.html&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),Z=e("Specific format reference: "),ee={href:"https://github.com/async-profiler/async-profiler/blob/v2.9/src/arguments.cpp#L52",target:"_blank",rel:"noopener noreferrer"},ae=e("arguments.cpp"),se=n(`<h2 id="view-all-supported-actions" tabindex="-1"><a class="header-anchor" href="#view-all-supported-actions" aria-hidden="true">#</a> View all supported actions</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler actions
Supported Actions: <span class="token punctuation">[</span>resume, dumpCollapsed, getSamples, start, list, version, execute, meminfo, stop, load, dumpFlat, dump, actions, dumpTraces, status, check<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="view-version" tabindex="-1"><a class="header-anchor" href="#view-version" aria-hidden="true">#</a> View version</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler version
Async-profiler <span class="token number">2.9</span> built on May  <span class="token number">8</span> <span class="token number">2023</span>
Copyright <span class="token number">2016</span>-2021 Andrei Pangin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="configure-java-stack-depth" tabindex="-1"><a class="header-anchor" href="#configure-java-stack-depth" aria-hidden="true">#</a> Configure Java stack depth</h2><p>You can use <code>-j</code> or <code>--jstackdepth</code> option to configure maximum Java stack depth. This option will be ignored if value is greater than default 2048. This option is useful when you don&#39;t want to see stacks that are too deep. Below is usage example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-j</span> <span class="token number">256</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="profiling-different-threads-separately" tabindex="-1"><a class="header-anchor" href="#profiling-different-threads-separately" aria-hidden="true">#</a> Profiling different threads separately</h2><p>You can use <code>-t</code> or <code>--threads</code> flag option to profile different threads separately, each stack trace will end with a frame that denotes a single thread.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-t</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="configure-include-exclude-to-filter-data" tabindex="-1"><a class="header-anchor" href="#configure-include-exclude-to-filter-data" aria-hidden="true">#</a> Configure include/exclude to filter data</h2><p>If the application is complex and generates a lot of content, and you want to focus on only part of stack traces, you can filter stack traces by <code>--include/--exclude</code>. <code>--include</code> defines the name pattern that must be present in the stack traces, while <code>--exclude</code> is the pattern that must not occur in any of stack traces in the output.A pattern may begin or end with a star <code>*</code> that denotes any (possibly empty) sequence of characters. such as</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler stop --include<span class="token string">&#39;java/*&#39;</span> <span class="token parameter variable">--include</span> <span class="token string">&#39;com/demo/*&#39;</span> --exclude<span class="token string">&#39;*Unsafe.park*&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>Both <code>--include/--exclude</code> support being set multiple times, but need to be configured at the end of the command line. You can also use short parameter format <code>-I/-X</code>. Note that <code>--include/--exclude</code> only supports configuration at <code>stop</code> action or <code>start</code> action with <code>-d</code>/<code>--duration</code> parameter, otherwise it will not take effect.</p></blockquote><h2 id="specify-execution-time" tabindex="-1"><a class="header-anchor" href="#specify-execution-time" aria-hidden="true">#</a> Specify execution time</h2><p>For example, if you want the profiler to automatically end after 300 seconds, you can specify it with the <code>-d</code>/<code>--duration</code> parameter in collect action:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler collect <span class="token parameter variable">--duration</span> <span class="token number">300</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="generate-jfr-format-result" tabindex="-1"><a class="header-anchor" href="#generate-jfr-format-result" aria-hidden="true">#</a> Generate jfr format result</h2><blockquote><p>Note that jfr only supports configuration at <code>start</code>. If it is specified at <code>stop</code>, it will not take effect.</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>profiler start --file /tmp/test.jfr
profiler start -o jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>file</code> parameter supports some variables:</p><ul><li>Timestamp: <code>--file /tmp/test-%t.jfr</code></li><li>Process ID: <code>--file /tmp/test-%p.jfr</code></li></ul><p>The generated results can be viewed with tools that support the jfr format. such as:</p><ul><li>JDK Mission Control: https://github.com/openjdk/jmc</li><li>JProfiler: https://github.com/alibaba/arthas/issues/1416</li></ul><h2 id="control-details-in-result" tabindex="-1"><a class="header-anchor" href="#control-details-in-result" aria-hidden="true">#</a> Control details in result</h2>`,25),ie=e("The "),ne=a("code",null,"-s",-1),te=e(" parameter will use simple name instead of Fully qualified name, e.g. "),oe=a("code",null,"MathGame.main",-1),re=e(" instead of "),le=a("code",null,"demo.MathGame.main",-1),de=e(". The "),ce=a("code",null,"-g",-1),pe=e(" parameter will use method signatures instead of method names, e.g. "),he=a("code",null,"demo.MathGame.main([Ljava/lang/String;)V",-1),ue=e(" instead of "),me=a("code",null,"demo.MathGame.main",-1),fe=e(". There are many parameters related to result format details, you can refer to "),ve={href:"https://github.com/async-profiler/async-profiler#readme",target:"_blank",rel:"noopener noreferrer"},be=e("async-profiler README"),ge=e(" and "),_e={href:"https://github.com/async-profiler/async-profiler/discussions",target:"_blank",rel:"noopener noreferrer"},xe=e("async-profiler Github Discussions"),ye=e(" and other information."),ke=n(`<p>For example, in command below, <code>-s</code> use simple name for Java class, <code>-g</code> show method signatures, <code>-a</code> will annotate Java methods, <code>-l</code> will prepend library names for native method, <code>--title</code> specify a title for flame graph page, <code>--minwidth</code> will skip frames smaller than 15% in flame graph, <code>--reverse</code> will generate stack-reversed FlameGraph / Call tree.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>profiler stop -s -g -a -l --title &lt;flametitle&gt; --minwidth 15 --reverse
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="the-unknown-in-profiler-result" tabindex="-1"><a class="header-anchor" href="#the-unknown-in-profiler-result" aria-hidden="true">#</a> The &#39;unknown&#39; in profiler result</h2><ul><li>https://github.com/jvm-profiling-tools/async-profiler/discussions/409</li></ul><h2 id="config-locks-allocations-profiling-threshold" tabindex="-1"><a class="header-anchor" href="#config-locks-allocations-profiling-threshold" aria-hidden="true">#</a> Config locks/allocations profiling threshold</h2><p>When profiling in locks or allocations event, you can use <code>--lock</code> or <code>--alloc</code> to config thresholds, for example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> lock <span class="token parameter variable">--lock</span> 10ms
profiler start <span class="token parameter variable">-e</span> alloc <span class="token parameter variable">--alloc</span> 2m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>will profile contended locks longer than 10ms (default unit is ns if no unit is specified), or profile allocations with 2m BYTES interval.</p><h2 id="config-jfr-chunks" tabindex="-1"><a class="header-anchor" href="#config-jfr-chunks" aria-hidden="true">#</a> Config JFR chunks</h2><p>When using JFR as output format, you can use <code>--chunksize</code> or <code>--chunktime</code> to config approximate size (in bytes, default value is 100MB) and time limits (default value is 1 hour) for a single JFR chunk. For example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-f</span> profile.jfr <span class="token parameter variable">--chunksize</span> 100m <span class="token parameter variable">--chunktime</span> 1h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="group-threads-by-scheduling-policy" tabindex="-1"><a class="header-anchor" href="#group-threads-by-scheduling-policy" aria-hidden="true">#</a> Group threads by scheduling policy</h2><p>You can use <code>--sched</code> flag option to group threads in output by Linux-specific scheduling policy: BATCH/IDLE/OTHER, for example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--sched</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The second line from bottom in flamegraph represent the scheduling policy.</p><h2 id="build-allocation-profile-from-live-objects-only" tabindex="-1"><a class="header-anchor" href="#build-allocation-profile-from-live-objects-only" aria-hidden="true">#</a> Build allocation profile from live objects only</h2><p>Use <code>--live</code> flag option to retain allocation samples with live objects only (object that have not been collected by the end of profiling session). Useful for finding Java heap memory leaks.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--live</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="config-method-of-collecting-c-stack-frames" tabindex="-1"><a class="header-anchor" href="#config-method-of-collecting-c-stack-frames" aria-hidden="true">#</a> Config method of collecting C stack frames</h2><p>Use <code>--cstack MODE</code> to config how to walk native frames (C stack). Possible modes are fp (Frame Pointer), dwarf (DWARF unwind info), lbr (Last Branch Record, available on Haswell since Linux 4.1), and no (do not collect C stack).</p><p>By default, C stack is shown in cpu, itimer, wall-clock and perf-events profiles. Java-level events like alloc and lock collect only Java stack.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler <span class="token parameter variable">--cstack</span> fp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The command above will collection Frame Pointer of C stacks.</p><h2 id="begin-or-end-profiling-when-function-is-executed" tabindex="-1"><a class="header-anchor" href="#begin-or-end-profiling-when-function-is-executed" aria-hidden="true">#</a> Begin or end profiling when FUNCTION is executed</h2><p>Use <code>--begin function</code> and <code>--end function</code> to automatically start/stop profiling when the specified native function is executed. Its main purpose is to profile certain JVM phases like GC and Safepoint pauses. You should use native function name defined in a JVM implement, for example <code>SafepointSynchronize::begin</code> and <code>SafepointSynchronize::end</code> in HotSpot JVM.</p><h3 id="time-to-safepoint-profiling" tabindex="-1"><a class="header-anchor" href="#time-to-safepoint-profiling" aria-hidden="true">#</a> Time-to-safepoint profiling</h3><p>The <code>--ttsp</code> option is an alias for <code>--begin SafepointSynchronize::begin --end RuntimeService::record_safepoint_synchronized</code>. It is not a separate event type, but rather a constraint. Whatever event type you choose (e.g. cpu or wall), the profiler will work as usual, except that only events between the safepoint request and the start of the VM operation will be recorded.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--begin</span> SafepointSynchronize::begin <span class="token parameter variable">--end</span> RuntimeService::record_safepoint_synchronized
profiler <span class="token parameter variable">--ttsp</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="use-events-from-profiler-for-java-flight-recording" tabindex="-1"><a class="header-anchor" href="#use-events-from-profiler-for-java-flight-recording" aria-hidden="true">#</a> Use events from profiler for Java Flight Recording</h2><p>Use <code>--jfrsync CONFIG</code> to start Java Flight Recording with the given configuration synchronously with the profiler. The output .jfr file will include all regular JFR events, except that execution samples will be obtained from async-profiler. This option implies -o jfr.</p>`,30),we=a("code",null,"CONFIG",-1),je=e(" can be "),Te=a("code",null,"profile",-1),Se=e(', means using the predefined JFR config "profile" in '),Fe=a("code",null,"$JAVA_HOME/lib/jfr/",-1),Ce=e(", or full path of a JFR configuration file (.jfc), this value has the same format with "),Be={href:"https://docs.oracle.com/en/java/javase/17/docs/specs/man/jcmd.html",target:"_blank",rel:"noopener noreferrer"},Je=e("settings option of JFR.start"),Ge=e("."),Re=n(`<p>For example, command below use &quot;profile&quot; config of JFR:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> cpu <span class="token parameter variable">--jfrsync</span> profile <span class="token parameter variable">-f</span> combined.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="run-profiler-in-a-loop" tabindex="-1"><a class="header-anchor" href="#run-profiler-in-a-loop" aria-hidden="true">#</a> Run profiler in a loop</h2><p>Use <code>--loop TIME</code> to run profiler in a loop (continuous profiling). The argument is either a clock time (hh:mm:ss) or a loop duration in seconds, minutes, hours, or days. Make sure the filename includes a timestamp pattern, or the output will be overwritten on each iteration. The command below will run profiling endlessly and save records of each hour to a jfr file.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--loop</span> 1h <span class="token parameter variable">-f</span> /var/log/profile-%t.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="timeout-option" tabindex="-1"><a class="header-anchor" href="#timeout-option" aria-hidden="true">#</a> <code>--timeout</code> option</h2><p>This option specifies the time when profiling will automatically stop. The format is the same as in loop: it is either a wall clock time (12:34:56) or a relative time interval (2h).</p>`,7),Ie=e("Both "),Me=a("code",null,"--loop",-1),Ne=e(" and "),Ve=a("code",null,"--timeout",-1),Ae=e(" are used for "),Ee=a("code",null,"start",-1),Pe=e(" action but not for "),$e=a("code",null,"collect",-1),De=e(" action, for further information refer to "),Le={href:"https://github.com/async-profiler/async-profiler/discussions/789",target:"_blank",rel:"noopener noreferrer"},Oe=e("async-profiler Github Discussions"),Ue=e(".");function Ye(qe,ze){const s=c("ExternalLinkIcon");return l(),d("div",null,[h,a("p",null,[a("a",u,[m,f,i(s)])]),a("div",v,[b,a("p",null,[g,a("a",_,[x,i(s)])])]),y,k,a("p",null,[w,j,T,a("a",S,[F,i(s)]),C]),B,a("p",null,[J,G,R,a("a",I,[M,i(s)]),N,V,A,E,P]),$,a("p",null,[D,a("a",L,[O,i(s)]),U,Y,q]),z,a("p",null,[K,a("a",H,[W,i(s)]),X]),Q,a("p",null,[Z,a("a",ee,[ae,i(s)])]),se,a("p",null,[ie,ne,te,oe,re,le,de,ce,pe,he,ue,me,fe,a("a",ve,[be,i(s)]),ge,a("a",_e,[xe,i(s)]),ye]),ke,a("p",null,[we,je,Te,Se,Fe,Ce,a("a",Be,[Je,i(s)]),Ge]),Re,a("p",null,[Ie,Me,Ne,Ve,Ae,Ee,Pe,$e,De,a("a",Le,[Oe,i(s)]),Ue])])}const We=r(p,[["render",Ye],["__file","profiler.html.vue"]]);export{We as default};
